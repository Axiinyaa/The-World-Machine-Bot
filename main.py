import interactions
import os
import random
import urllib.request
import lavalink
import datetime
import json

# Other Scripts
import custom_source
import dialogue_generator
import ask_responses
import profile_icons as icons
import keep_online # Used to keep the bot online.

# Extension Libraries
from interactions.ext.wait_for import wait_for_component, setup
from interactions.ext.lavalink import VoiceClient
from interactions.ext.files import command_send

TOKEN = os.environ['BOT-TOKEN']

try:
    bot = VoiceClient(token=TOKEN)
except:
    os.system('kill 1') # Prevents the bot from continously getting stuck on the same server.
    
bot.load('interactions.ext.files')

setup(bot)

responses = []

@bot.event()
async def on_start():
    global responses
    
    responses = list(divide_chunks(ask_responses.responses, 2))
    random.shuffle(responses)

    bot.lavalink_client.add_node(
        host = '51.161.130.134',
        port = 10333,
        password = 'youshallnotpass',
        region = "eu"
    ) # Woah, neat! Free Lavalink!
    
    bot.lavalink_client.add_event_hook(track_hook)

    await bot.change_presence(
        interactions.ClientPresence(
            status=interactions.StatusType.ONLINE,
            activities=[
                interactions.PresenceActivity(
                    name="over Niko",
                    type=interactions.PresenceActivityType.WATCHING)
            ]))

    await change_picture()
    
    print(f"{bot.me.name} is ready!")

async def change_picture():
    profile_pictures = icons.icons
    ran_num = random.randint(0, len(profile_pictures) - 1)
    picture = profile_pictures[ran_num]

    urllib.request.urlretrieve(picture, "Images/picture.png")
    image = interactions.Image("Images/picture.png")

    try:
        await bot.modify(avatar=image, username="The World Machine")
    except:
        print("Couldn't change avatar. Whoops, either way...")


@bot.command(name="say",
             description="Repeats whatever the user puts in.",
             options=[
                 interactions.Option(name="text",
                                     description="The text to repeat.",
                                     required=True,
                                     type=interactions.OptionType.STRING)
             ])
async def say_command(ctx: interactions.CommandContext, text: str):
  #stops the bot from mass pinging users
    if '@everyone' in text:
        text = text.replace('@everyone', '@â€Ževeryone')

    if '@here' in text:
        text = text.replace('@here', '@â€Žhere')
    channel = ctx.channel
    await channel.send(text)
    msg = await ctx.send("** **") # Makes sure it returns something 
    await msg.delete()


@bot.command(name="text-generator",
             description="Generates text in the style of OneShot!",
             options=[
                 interactions.Option(
                     name="text",
                     description="The text to add.",
                     type=interactions.OptionType.STRING,
                     required=True,
                     max_length = 184
                 )
             ])
async def text_gen(ctx: interactions.CommandContext, text: str):

    #modal = await GenerateModal()

    #await ctx.popup(modal)

    text_ = await GenerateModal()

    await ctx.send(f"<@{ctx.author.id}>, select a text face!", components=text_, ephemeral=True)

    async def check(ctx):
        return True
    
    text_ctx : interactions.ComponentContext = await wait_for_component(bot, components=text_, check=check)

    val = int(text_ctx.data.values[0])

    print(val)

    picture = icons.dialogue_pictures[val]
    urllib.request.urlretrieve(picture, "Images/niko.png")

    msg = await text_ctx.send("``Generating Image...``")
    await dialogue_generator.test(text)
    await msg.delete()
    file = interactions.File(filename="Images/pil_text.png")
    await command_send(text_ctx, content=f"Generated by: {ctx.author.name}", files=file)

async def GenerateModal():
    normal = interactions.Emoji(id=1019605517695463484)
    talk = interactions.Emoji(id=1019605516210667521)
    left = interactions.Emoji(id=1019605499685113909)
    right = interactions.Emoji(id=1019605501228630107)
    shock = interactions.Emoji(id=1019605514843336764)
    shocked = interactions.Emoji(id=1019605502365274252)
    confused = interactions.Emoji(id=1019605503485149377)
    popcorn = interactions.Emoji(id=1019605504957366282)
    wink = interactions.Emoji(id=1019605506152734790)
    pancake = interactions.Emoji(id=1019605507314548862)
    blush = interactions.Emoji(id=1019605508421857401)
    cry = interactions.Emoji(id=1019605509625618522)
    upset = interactions.Emoji(id=1019605510787453058)
    fedup = interactions.Emoji(id=1019605511802458185)
    cool = interactions.Emoji(id=1019605513387900978)
    
    
    awesome = [
        interactions.SelectOption(
            label = "Normal",
            emoji = normal,
            value = 0
        ),
        interactions.SelectOption(
            label = "Talk",
            emoji = talk,
            value = 1
        ),
        interactions.SelectOption(
            label = "Look Left",
            emoji = left,
            value = 2
        ),
        interactions.SelectOption(
            label = "Look Right",
            emoji = right,
            value = 3
        ),
        interactions.SelectOption(
            label = "Disgusted",
            emoji = shock,
            value = 4
        ),
        interactions.SelectOption(
            label = "Shocked",
            emoji = shocked,
            value = 5
        ),
        interactions.SelectOption(
            label = "Confused",
            emoji = confused,
            value = 6
        ),
        interactions.SelectOption(
            label = "Popcorn",
            emoji = popcorn,
            value = 7
        ),
        interactions.SelectOption(
            label = "Wink",
            emoji = wink,
            value = 8
        ),
        interactions.SelectOption(
            label = "Pancakes",
            emoji = pancake,
            value = 9
        ),
        interactions.SelectOption(
            label = "Blush",
            emoji = blush,
            value = 10
        ),
        interactions.SelectOption(
            label = "Cry",
            emoji = cry,
            value = 11
        ),
        interactions.SelectOption(
            label = "Upset",
            emoji = upset,
            value = 12
        ),
        interactions.SelectOption(
            label = "Fed Up",
            emoji = fedup,
            value = 13
        ),
        interactions.SelectOption(
            label = "Kip, but Cool.",
            emoji = cool,
            value = 14
        ),
    ]

    return interactions.SelectMenu(
        type = interactions.ComponentType.SELECT,
        options=awesome,
        placeholder="Select a face!",
        custom_id="menu_component",
    )


@bot.command(
    name="ask",
    description=f"Ask {bot.me.name} any yes or no question, like an 8-Ball!",
    options=[
        interactions.Option(name="question",
                            description="The question ðŸ¥´",
                            type=interactions.OptionType.STRING,
                            required=True)
    ])
async def eight_ball(ctx: interactions.CommandContext, question: str):
    rand = random.randint(0, 1)

    resp_id = 0
    length = len(question)

    if (length > 24):
        resp_id = 6
    elif (length > 20):
        resp_id = 5
    elif (length > 16):
        resp_id = 4
    elif (length > 12):
        resp_id = 3
    elif (length > 8):
        resp_id = 2
    elif (length > 4):
        resp_id = 1
    else:
        pass

    print(resp_id, rand, length)

    final_response = responses[resp_id][rand]

    embed = interactions.Embed(
        title=final_response,
        footer=interactions.EmbedFooter(
            text=f"The question asked was: \"{question}\""
        )
    )

    await ctx.send(embeds=embed)


def divide_chunks(l, n):
    # looping till length l
    for i in range(0, len(l), n):
        yield l[i:i + n]


@bot.command(
    name="music",
    options=[
        interactions.Option(
            name="play",
            description="Add Music to the music queue to be played.",
            type=interactions.OptionType.SUB_COMMAND,
            options=[                
                interactions.Option(
                    name="search",
                    description=
                    "Search for the track you are looking for.",
                    required=True,
                    type=interactions.OptionType.STRING
                )
            ]
        ),
        interactions.Option(
            name = "remove",
            description = "Removes at an index [TEMPORARY].",
            type = interactions.OptionType.SUB_COMMAND,
            options = [
                interactions.Option(
                    name = "fromindex",
                    description = "i love you",
                    type = interactions.OptionType.INTEGER,
                    required = True
                )
            ]
        ),

        interactions.Option(
            name = "get_player",
            description = "See what is playing now.",
            type = interactions.OptionType.SUB_COMMAND
        )
    ])
        
async def music(ctx: interactions.CommandContext, sub_command: str, search: str = "", fromindex: int = 0):
    if (ctx.author.voice == None):
        await ctx.send("Sorry! You need to be in a voice channel to use this command.", ephemeral = True)
        return

    if (ctx.author.voice.guild_id != ctx.guild_id):
        await ctx.send("Sorry! You need to be in a voice channel to use this command.", ephemeral = True)
        return
    
    await ctx.defer()
    if (sub_command == "play"):
        
        try:
            player = await bot.connect(ctx.guild_id, ctx.author.voice.channel_id, self_deaf = True)
        except:
            player = await bot.connect(ctx.guild_id, ctx.channel_id, self_deaf = True)

        if (search.startswith("https://open.spotify.com/")):
            search = await custom_source.SearchSpotify(search)
        
        results = await player.node.get_tracks(f"ytsearch:{search}")
        track = lavalink.AudioTrack(results["tracks"][0], int(ctx.author.id))
        player.add(requester=int(ctx.author.id), track=track)
        
        player.store(f'channel {ctx.guild_id}', ctx)

        if not player.is_playing:
            await player.play()
        else:
            cool = interactions.Embed(
                title = f"**Added:** [{track.title}] to queue.",
                thumbnail = interactions.EmbedImageStruct( url = f"https://i3.ytimg.com/vi/{track.identifier}/maxresdefault.jpg", height = 720, width = 1280),
                description = f"Current Position: {len(player.queue)}",
                url = player.current.uri
            )
            await ctx.send(embeds = cool)
    
    elif (sub_command == "remove"):
        player = await bot.connect(ctx.guild_id, ctx.channel_id),

        player = player[0]

        song = pop(player.queue[fromindex - 1])
        
        await ctx.send("Removed song!")
    
    elif (sub_command == "get_player"):
        player = await bot.connect(ctx.guild_id, ctx.channel_id)

        await ShowPlayer(ctx, player, True)

# --------------------------------------------------------------------

async def ShowPlayer(ctx : interactions.CommandContext, player, show_timeline : bool):
    msg = ""

    player = await bot.connect(ctx.guild_id, ctx.author.voice.channel_id, self_deaf = True)
    
    if (player.is_playing):
        embed = await GenerateEmbed(player.current.identifier, player, show_timeline)
        msg = await ctx.send('`Loading Player`')
        buttons = await GetButtons(msg.id)
        msg = await msg.edit(embeds=embed, components=buttons)
    else:
        embed = interactions.Embed(
                title = "Not Currently Playing Anything",
                thumbnail = interactions.EmbedImageStruct( url = "https://shortcut-test2.s3.amazonaws.com/uploads/role/attachment/346765/default_Enlarged_sunicon.png"),
                description = "Use /play music to add music."
            )
        
        await ctx.send(embeds=embed)
        return
    

    async def check(ctx):
        return True
        
    while True:
        print('waiting')
        button_ctx = await wait_for_component(bot, components=buttons, check=check)

        player = await bot.connect(ctx.guild_id, ctx.author.voice.channel_id, self_deaf = True)

        if (ctx.author.voice == None):
            await ctx.send("Sorry! You need to be in a voice channel to use this command.", ephemeral = True)
            return
        
        data = button_ctx.data.custom_id

        print(data)
    
        if (data == f"play {msg.id}"):
            is_paused = player.fetch("is_paused")
            
            if not (is_paused):
                await player.set_pause(True)
                player.store("is_paused", True)
                message = "`Paused the current track playing.`"
            elif (is_paused):
                await player.set_pause(False)
                player.store("is_paused", False)
                message = "`Resumed the current track playing.`"
        elif (data == f"skip {msg.id}"):
            await button_ctx.send("`Skipped this track!`")
            await player.skip()
        elif (data == f"queue {msg.id}"):
            if (len(player.queue) > 0):
                button = [
                    interactions.Button(
                        label="Shuffle",
                        style = interactions.ButtonStyle.PRIMARY,
                        custom_id = f"shuffle {button_ctx.guild_id}"
                    ),
                    interactions.Button(
                        label="Remove Song",
                        style = interactions.ButtonStyle.DANGER,
                        custom_id = f"remove {button_ctx.guild_id}"
                    ),
                ]

                options = []
                i = 0

                for song in player.queue:
                    options.append(
                        interactions.SelectOption(
                            label = f'{i + 1}. {song.title}',
                            value = i
                        )
                    )

                    i += 1

                select = interactions.SelectMenu(
                    options=options,
                    placeholder= 'What Song?',
                    custom_id="woo",
                )
                
                queue = await GenerateQueue(button_ctx, player)
    
                msg = await button_ctx.send(embeds = queue, components=button)
    
                async def checkers(ctx):
                    return True
    
                while True:
                    shuffle_ctx = await wait_for_component(bot, components = button, check=checkers)

                    if (shuffle_ctx.data.custom_id == f'shuffle {button_ctx.guild_id}'):
                        random.shuffle(player.queue)
                    
                        queue = await GenerateQueue(button_ctx, player)
                        await shuffle_ctx.edit('`Shuffled Queue.`', embeds = queue, components=button)
                    else:
                        await shuffle_ctx.send(components=select, ephemeral = True)

                        contexto : interactions.ComponentContext = await wait_for_component(bot, components = select, check=checkers)

                        song_ = player.queue.pop(int(contexto.data.values[0]))
                        
                        await contexto.channel.send(f'<@{contexto.author.id}> Removed {song_.title} from the queue.')
            else:
                message = "`Queue is currently empty :(`"
        elif (data == f"stop {msg.id}"):
            await bot.disconnect(ctx.guild_id)
            await button_ctx.send("Stopped playback :(")
        elif (data == f"loop {msg.id}"):
            if not (player.repeat):
                player.set_repeat(True)
                message = "`Looping Queue!`"
            else:
                player.set_repeat(False)
                message = "`Loop Stopped!`"
                
        funny_embed = await GenerateEmbed(player.current.identifier, player, True)
        await button_ctx.edit(message, embeds = funny_embed)
        
async def track_hook(event):
    if isinstance(event, lavalink.events.TrackStartEvent):
        ctx = event.player.fetch(f'channel {event.player.guild_id}')
        await ShowPlayer(ctx, event.player, False)
    elif isinstance(event, lavalink.events.QueueEndEvent):
        ctx = event.player.fetch(f'channel {event.player.guild_id}')
        await ctx.send("`End of queue! Add more music or audio using /music play.`")
    elif isinstance(event, lavalink.events.TrackExceptionEvent):
        ctx = event.player.fetch(f'channel {event.player.guild_id}')
        await ctx.send("An error occurred when attempting to play the track. Try Skipping the track and replaying it later.")
        await ctx.send(f"`{event.exception}`")
    elif isinstance(event, lavalink.events.TrackStuckEvent):
        ctx = event.player.fetch(f'channel {event.player.guild_id}')
        await ctx.send("Whoops track is stuck that kind of sucks")

async def GenerateQueue(button_ctx, player):
    queue = player.queue
    list_ = ""

    try:
        for song in queue:
            time = datetime.datetime.fromtimestamp(song.duration / 1000).strftime('%M:%S')
            list_ = f"{list_}**{queue.index(song) + 1}.** `{song.title}` *({time})*\n"
    except:
        list_ = ""
    
    if (len(list_) > 0):
        return interactions.Embed(
        title = "Music Queue",
        description = f"\n**Currently Playing:** `{player.current.title}`\n\n",
        thumbnail = interactions.EmbedImageStruct( url = "https://shortcut-test2.s3.amazonaws.com/uploads/role/attachment/346765/default_Enlarged_sunicon.png" ),
        fields = [
            interactions.EmbedField(
                name = "Song List",
                value = list_,
                inline = True
                )
            ]
        )

async def GenerateEmbed(id : str, player, show_timeline):
    if (player.is_playing):
        current_length = player.position / 1000
        song_length = player.current.duration / 1000
    
        l_length = list("â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘")
        
        calc_length = round((current_length / song_length) * len(l_length))
    
        i = 0
    
        new_c_length = datetime.datetime.fromtimestamp(current_length).strftime('%M:%S')
        new_length = datetime.datetime.fromtimestamp(song_length).strftime('%M:%S')
        
        for char in l_length:
            if (i < calc_length):
                l_length[i] = "â–ˆ"
            i += 1
        
        length = "".join(l_length)
    
        if (show_timeline):
            return interactions.Embed(
                title = f"**Now Playing:** [{player.current.title}]",
                thumbnail = interactions.EmbedImageStruct( url = f"https://i3.ytimg.com/vi/{id}/maxresdefault.jpg", height = 720, width = 1280),
                description = f"{length} \n\n *{new_c_length} / {new_length}*",
                footer = interactions.EmbedFooter( text = 'Do /music get_player if the buttons don\'t work or you\'ve lost the player.'),
                url = player.current.uri
            )
        else:
            return interactions.Embed(
                title = f"**Now Playing:** [{player.current.title}]",
                thumbnail = interactions.EmbedImageStruct( url = f"https://i3.ytimg.com/vi/{id}/maxresdefault.jpg", height = 720, width = 1280),
                description = f"<:nikoplush:608731310285914143>\n\n *{new_length}*",
                footer = interactions.EmbedFooter( text = 'Do /music get_player if the buttons don\'t work or you have lost the player.'),
                url = player.current.uri
            )

async def GetButtons(guild_id):
    play_emoji = interactions.Emoji(name="playorpause", id=1019286927888883802)
    stop_emoji = interactions.Emoji(name="stopmusic", id=1019286931504386168)
    queue_emoji = interactions.Emoji(name="openqueue", id = 1019286929059086418)
    loop_song_emoji = interactions.Emoji(name="loopsong", id=1019286926404091914)
    skip_emoji = interactions.Emoji(name="skipmusic", id=1019286930296410133)

    print(guild_id)
    
    return [
        # Queue Button
        interactions.Button(
            style=interactions.ButtonStyle.DANGER,
            emoji = queue_emoji,
            custom_id = f"queue {guild_id}",
        ),
        # Loop Button
        interactions.Button(
            style=interactions.ButtonStyle.DANGER,
            custom_id = f"loop {guild_id}",
            emoji = loop_song_emoji
        ),

        # Play Button
        interactions.Button(
            style=interactions.ButtonStyle.DANGER,
            custom_id = f"play {guild_id}",
            emoji = play_emoji
        ),
        # Skip Button
        interactions.Button(
            style=interactions.ButtonStyle.DANGER,
            custom_id = f"skip {guild_id}",
            emoji = skip_emoji
        ),
        # Stop Button
        interactions.Button(
            style=interactions.ButtonStyle.DANGER,
            custom_id = f"stop {guild_id}",
            emoji = stop_emoji
        ),
    ]

@bot.command(
    name = "purge",
    description = "Delete multiple messages at once. User must have the 'Administrator' Permission.",
    default_member_permissions=interactions.Permissions.ADMINISTRATOR,
    options = [
        interactions.Option(
            name = "amount",
            required = True,
            description = "The amount of messages to delete up to 100.",
            type = interactions.OptionType.INTEGER,
            max_value = 100
        )
    ]
)
async def testing_lol(ctx : interactions.CommandContext, amount : int):
    await ctx.channel.purge(amount)
    await ctx.send(f"Deleted {amount} messages.", ephemeral=True)

@bot.command(
    name = "actions",
    description = "Do an action towards someone.",
    options = [
        interactions.Option(
            name = "choices",
            description = "The action you wish to do",
            type = interactions.OptionType.STRING,
            required = True,
            choices = [
                interactions.Choice(
                    name = "Hug",
                    value = 'hugg'
                ),

                interactions.Choice(
                    name = "Kiss",
                    value = 'kiss'
                ),

                interactions.Choice(
                    name = "Cuddle",
                    value = 'cuddl'
                ),

                interactions.Choice(
                    name = "Pet",
                    value = 'pett'
                ),

                interactions.Choice(
                    name = "Punch",
                    value = 'punch'
                ),

                interactions.Choice(
                    name = "Slap",
                    value = 'slapp'
                ),

                interactions.Choice(
                    name = "Kill",
                    value = "murder"
                ),
            ]
        ),

        interactions.Option(
            name = "user",
            required = True,
            description = 'The person to do the action towards.',
            type=interactions.OptionType.USER
        )
    ]
)
async def action(ctx : interactions.CommandContext, user : str, choices : str):

    verb = f'{choices}ed'

    title_ = await GetTitles(choices)
    
    if (user.id == ctx.author.user.id):
        if (choices == 'murder' or choices == 'slapp' or choices == 'punch'):
            await ctx.send('Hey! Don\'t do that. That ain\'t cool. Love yourself. â™¥', ephemeral = True)
            return
        else:
            embed = interactions.Embed(
                title = f'{title_}!',
                description = f'<@{ctx.author.user.id}> {verb} themself.'
            )   
    else:
        embed = interactions.Embed(
            title = f'{title_}!',
            description = f'<@{ctx.author.user.id}> {verb} <@{user.id}>.'
        )

    button = interactions.Button(
        style = interactions.ButtonStyle.PRIMARY,
        label = await GetTitles(choices) + ' back',
        custom_id = f'sussy {user.id}'
    )

    if (user.id == ctx.author.user.id):
        msg = await ctx.send(embeds = embed)
    else:
        msg = await ctx.send(embeds = embed, components = button)

    async def check(ctx):
        if (ctx.author.id == user.id):
            return True
        else:
            await ctx.send(f'Sorry! Only the user <@{user.id}> can respond to this action!', ephemeral = True)
            return False

    
    if (user.id == bot.me.id):
        embed = interactions.Embed(
            title = f'A {title_} back!',
            description = f'<@{user.id}> {verb} <@{ctx.author.user.id}> back.'
        )
    
        await msg.edit(components = [])
    
        await ctx.send(embeds=embed)
    else:
        button_ctx = await wait_for_component(bot, components=button, check=check)

        embed = interactions.Embed(
            title = f'A {title_} back!',
            description = f'<@{user.id}> {verb} <@{ctx.author.user.id}> back.'
        )
    
        await msg.edit(components = [])
    
        await button_ctx.send(embeds=embed)

async def GetTitles(choice):
    if (choice == 'hugg'):
        return 'Hug'
    if (choice == 'kiss'):
        return 'Kiss'
    if (choice == 'cuddl'):
        return 'Cuddle'
    if (choice == 'pett'):
        return 'Pet'
    if (choice == 'slapp'):
        return 'Slap'
    if (choice == 'punch'):
        return 'Punch'
    if (choice == 'murder'):
        return 'Kill'

bot.start()